import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
import os
from sklearn.preprocessing import StandardScaler

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="Segmentaci√≥n de Clientes RFM",
    page_icon="üìä",
    layout="wide"
)

# Aplicar estilo CSS personalizado
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .cluster-card {
        padding: 1rem;
        border-radius: 10px;
        border-left: 5px solid;
        margin-bottom: 1rem;
    }
</style>
""", unsafe_allow_html=True)

# T√≠tulo principal
st.markdown('<h1 class="main-header">üîç Segmentaci√≥n de Clientes - An√°lisis RFM</h1>', unsafe_allow_html=True)
st.markdown("**Proyecto de Miner√≠a de Datos ‚Äì Grupo 4**")
st.markdown("---")

# Cargar modelo y datos
@st.cache_resource
def cargar_modelo():
    try:
        ruta_base = r"E:\Descargas\Proyecto de Miner√≠a de Datos ‚Äì Grupo 4"
        modelo_path = os.path.join(ruta_base, "modelo_kmeans.pkl")
        modelo = joblib.load(modelo_path)
        return modelo
    except Exception as e:
        st.error(f"Error cargando el modelo: {e}")
        return None

@st.cache_data
def cargar_datos_originales():
    try:
        ruta_base = r"E:\Descargas\Proyecto de Miner√≠a de Datos ‚Äì Grupo 4"
        ruta_excel = os.path.join(ruta_base, "Online Retail.xlsx")
        df = pd.read_excel(ruta_excel)
        
        # Limpieza b√°sica (igual que en tu notebook)
        df["InvoiceDate"] = pd.to_datetime(df["InvoiceDate"], errors="coerce")
        df = df.dropna(subset=["CustomerID"])
        df = df[df["Quantity"] > 0]
        
        return df
    except Exception as e:
        st.error(f"Error cargando dataset: {e}")
        return None

@st.cache_data
def cargar_resultados_rfm():
    try:
        ruta_base = r"E:\Descargas\Proyecto de Miner√≠a de Datos ‚Äì Grupo 4"
        csv_path = os.path.join(ruta_base, "resultados_segmentacion.csv")
        rfm = pd.read_csv(csv_path, index_col=0)
        return rfm
    except:
        # Si no existe el CSV, calcular RFM desde cero
        df = cargar_datos_originales()
        if df is None:
            return None
            
        snapshot_date = df["InvoiceDate"].max() + pd.Timedelta(days=1)
        
        rfm = df.groupby("CustomerID").agg({
            "InvoiceDate": lambda x: (snapshot_date - x.max()).days,
            "InvoiceNo": "nunique",
            "UnitPrice": lambda x: (x * df.loc[x.index, "Quantity"]).sum()
        }).rename(columns={
            "InvoiceDate": "Recency",
            "InvoiceNo": "Frequency",
            "UnitPrice": "Monetary"
        })
        
        return rfm

# Sidebar para navegaci√≥n
st.sidebar.title("üß≠ Navegaci√≥n")
opcion = st.sidebar.radio(
    "Selecciona una secci√≥n:",
    ["üìä Dashboard General", "üë• An√°lisis de Segmentos", "üîç Buscar Cliente", "üìà Recomendaciones Estrat√©gicas"]
)

# Cargar recursos
modelo = cargar_modelo()
df_original = cargar_datos_originales()
rfm_data = cargar_resultados_rfm()

if df_original is None or rfm_data is None:
    st.error("No se pudieron cargar los datos. Verifica las rutas de archivo.")
    st.stop()

# --- SECCI√ìN 1: DASHBOARD GENERAL ---
if opcion == "üìä Dashboard General":
    st.header("üìä Dashboard General RFM")
    
    # M√©tricas principales
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        total_clientes = len(rfm_data)
        st.metric("Total Clientes", f"{total_clientes:,}")
    
    with col2:
        total_ventas = df_original['Quantity'].sum()
        st.metric("Total Productos Vendidos", f"{total_ventas:,}")
    
    with col3:
        ingresos_totales = (df_original['Quantity'] * df_original['UnitPrice']).sum()
        st.metric("Ingresos Totales", f"${ingresos_totales:,.2f}")
    
    with col4:
        transacciones_totales = df_original['InvoiceNo'].nunique()
        st.metric("Total Transacciones", f"{transacciones_totales:,}")
    
    st.markdown("---")
    
    # Distribuci√≥n de clusters
    col_left, col_right = st.columns([1, 1])
    
    with col_left:
        st.subheader("üìà Distribuci√≥n de Segmentos")
        
        if 'Cluster' in rfm_data.columns:
            cluster_counts = rfm_data['Cluster'].value_counts().sort_index()
            
            fig, ax = plt.subplots(figsize=(10, 6))
            colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7']
            bars = ax.bar([f'Segmento {i}' for i in cluster_counts.index], 
                         cluster_counts.values, 
                         color=colors[:len(cluster_counts)])
            
            ax.set_ylabel('N√∫mero de Clientes')
            ax.set_title('Clientes por Segmento RFM')
            plt.xticks(rotation=45)
            
            # Agregar valores en las barras
            for bar in bars:
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2., height,
                       f'{int(height)}\n({height/total_clientes*100:.1f}%)', 
                       ha='center', va='bottom')
            
            st.pyplot(fig)
    
    with col_right:
        st.subheader("üìã Resumen RFM por Segmento")
        
        if 'Cluster' in rfm_data.columns:
            resumen_clusters = rfm_data.groupby('Cluster').agg({
                'Recency': 'mean',
                'Frequency': 'mean', 
                'Monetary': 'mean'
            }).round(2)
            
            # Formatear para mejor visualizaci√≥n
            resumen_display = resumen_clusters.rename(columns={
                'Recency': 'Recencia (d√≠as)',
                'Frequency': 'Frecuencia',
                'Monetary': 'Valor Monetario ($)'
            })
            
            st.dataframe(resumen_display.style.background_gradient(cmap='Blues'))
    
    # Gr√°ficos de distribuci√≥n RFM
    st.subheader("üìä Distribuci√≥n de Variables RFM")
    
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))
    
    # Recency
    axes[0].hist(rfm_data['Recency'], bins=30, alpha=0.7, color='skyblue', edgecolor='black')
    axes[0].set_title('Distribuci√≥n de Recencia')
    axes[0].set_xlabel('D√≠as desde √∫ltima compra')
    axes[0].set_ylabel('Frecuencia')
    
    # Frequency
    axes[1].hist(rfm_data['Frequency'], bins=30, alpha=0.7, color='lightgreen', edgecolor='black')
    axes[1].set_title('Distribuci√≥n de Frecuencia')
    axes[1].set_xlabel('N√∫mero de transacciones')
    axes[1].set_ylabel('Frecuencia')
    
    # Monetary
    axes[2].hist(rfm_data['Monetary'], bins=30, alpha=0.7, color='salmon', edgecolor='black')
    axes[2].set_title('Distribuci√≥n de Valor Monetario')
    axes[2].set_xlabel('Valor total ($)')
    axes[2].set_ylabel('Frecuencia')
    
    plt.tight_layout()
    st.pyplot(fig)

# --- SECCI√ìN 2: AN√ÅLISIS DE SEGMENTOS ---
elif opcion == "üë• An√°lisis de Segmentos":
    st.header("üë• An√°lisis Detallado por Segmento")
    
    if 'Cluster' not in rfm_data.columns:
        st.warning("No se encontraron datos de segmentaci√≥n. Ejecuta primero el notebook de an√°lisis.")
        st.stop()
    
    # Selector de segmento
    segmento_seleccionado = st.selectbox(
        "Selecciona un segmento para analizar:",
        sorted(rfm_data['Cluster'].unique())
    )
    
    # Datos del segmento seleccionado
    segmento_data = rfm_data[rfm_data['Cluster'] == segmento_seleccionado]
    
    # M√©tricas del segmento
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Clientes en Segmento", len(segmento_data))
    
    with col2:
        st.metric("Recencia Promedio", f"{segmento_data['Recency'].mean():.1f} d√≠as")
    
    with col3:
        st.metric("Frecuencia Promedio", f"{segmento_data['Frequency'].mean():.1f}")
    
    with col4:
        st.metric("Valor Promedio", f"${segmento_data['Monetary'].mean():.2f}")
    
    st.markdown("---")
    
    # Visualizaciones comparativas
    col_viz1, col_viz2 = st.columns(2)
    
    with col_viz1:
        st.subheader("Comparaci√≥n de Recencia")
        fig, ax = plt.subplots(figsize=(10, 6))
        
        for cluster in sorted(rfm_data['Cluster'].unique()):
            data_cluster = rfm_data[rfm_data['Cluster'] == cluster]['Recency']
            color = 'red' if cluster == segmento_seleccionado else 'lightgray'
            alpha = 1.0 if cluster == segmento_seleccionado else 0.5
            ax.hist(data_cluster, bins=20, alpha=alpha, label=f'Segmento {cluster}', color=color)
        
        ax.set_xlabel('Recencia (d√≠as)')
        ax.set_ylabel('Frecuencia')
        ax.set_title('Distribuci√≥n de Recencia por Segmento')
        ax.legend()
        st.pyplot(fig)
    
    with col_viz2:
        st.subheader("Comparaci√≥n de Valor Monetario")
        fig, ax = plt.subplots(figsize=(10, 6))
        
        for cluster in sorted(rfm_data['Cluster'].unique()):
            data_cluster = rfm_data[rfm_data['Cluster'] == cluster]['Monetary']
            color = 'green' if cluster == segmento_seleccionado else 'lightgray'
            alpha = 1.0 if cluster == segmento_seleccionado else 0.5
            ax.hist(data_cluster, bins=20, alpha=alpha, label=f'Segmento {cluster}', color=color)
        
        ax.set_xlabel('Valor Monetario ($)')
        ax.set_ylabel('Frecuencia')
        ax.set_title('Distribuci√≥n de Valor por Segmento')
        ax.legend()
        st.pyplot(fig)
    
    # Top clientes del segmento
    st.subheader(f"üèÜ Top 10 Clientes - Segmento {segmento_seleccionado}")
    
    top_clientes = segmento_data.nlargest(10, 'Monetary')[['Recency', 'Frequency', 'Monetary']]
    st.dataframe(top_clientes.style.format({
        'Monetary': '${:,.2f}',
        'Recency': '{:.0f}',
        'Frequency': '{:.0f}'
    }))

# --- SECCI√ìN 3: BUSCAR CLIENTE ---
elif opcion == "üîç Buscar Cliente":
    st.header("üîç An√°lisis de Cliente Espec√≠fico")
    
    # Selector de cliente
    cliente_ids = rfm_data.index.astype(str).tolist()
    cliente_seleccionado = st.selectbox("Selecciona un CustomerID:", cliente_ids)
    
    if cliente_seleccionado:
        cliente_data = rfm_data.loc[float(cliente_seleccionado)]
        
        # Mostrar informaci√≥n del cliente
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("CustomerID", cliente_seleccionado)
        
        with col2:
            st.metric("Recencia", f"{cliente_data['Recency']:.0f} d√≠as")
        
        with col3:
            st.metric("Frecuencia", f"{cliente_data['Frequency']:.0f}")
        
        with col4:
            if 'Cluster' in cliente_data:
                st.metric("Segmento", f"Cluster {cliente_data['Cluster']}")
            else:
                st.metric("Segmento", "No asignado")
        
        st.markdown("---")
        
        # Valor monetario
        st.metric("Valor Monetario Total", f"${cliente_data['Monetary']:,.2f}")
        
        # Comparaci√≥n con el segmento
        if 'Cluster' in cliente_data:
            segmento_cliente = cliente_data['Cluster']
            segmento_promedio = rfm_data[rfm_data['Cluster'] == segmento_cliente].mean()
            
            st.subheader("üìä Comparaci√≥n con su Segmento")
            
            comparacion = pd.DataFrame({
                'Este Cliente': [
                    cliente_data['Recency'],
                    cliente_data['Frequency'], 
                    cliente_data['Monetary']
                ],
                'Promedio del Segmento': [
                    segmento_promedio['Recency'],
                    segmento_promedio['Frequency'],
                    segmento_promedio['Monetary']
                ]
            }, index=['Recencia', 'Frecuencia', 'Valor Monetario'])
            
            # Calcular diferencias porcentuales
            comparacion['Diferencia %'] = (
                (comparacion['Este Cliente'] - comparacion['Promedio del Segmento']) / 
                comparacion['Promedio del Segmento'] * 100
            ).round(1)
            
            st.dataframe(comparacion.style.format({
                'Este Cliente': '{:.2f}',
                'Promedio del Segmento': '{:.2f}',
                'Diferencia %': '{:.1f}%'
            }))

# --- SECCI√ìN 4: RECOMENDACIONES ESTRAT√âGICAS ---
elif opcion == "üìà Recomendaciones Estrat√©gicas":
    st.header("üìà Recomendaciones por Segmento")
    
    recomendaciones = {
        0: {
            "nombre": "üö™ Clientes Inactivos",
            "descripcion": "Alta recencia, baja frecuencia y valor monetario",
            "caracteristicas": ["No compran hace mucho tiempo", "Bajo historial de compras", "Bajo valor total"],
            "estrategias": [
                "üí° Campa√±as de reactivaci√≥n con descuentos especiales",
                "üí° Encuestas de satisfacci√≥n para entender su partida", 
                "üí° Programas de 'Te extra√±amos' con beneficios exclusivos",
                "üí° Email marketing con ofertas personalizadas"
            ],
            "objetivos": ["Recuperar al 20% de clientes", "Incrementar frecuencia de compra"]
        },
        1: {
            "nombre": "‚≠ê Clientes Leales", 
            "descripcion": "Recencia media, frecuencia constante y valor moderado",
            "caracteristicas": ["Clientes regulares", "Fidelidad comprobada", "Valor constante"],
            "estrategias": [
                "üí° Programas de fidelizaci√≥n con puntos canjeables",
                "üí° Acceso anticipado a nuevos productos y promociones",
                "üí° Comunicaci√≥n personalizada y reconocimiento especial",
                "üí° Ofertas de cross-selling basadas en historial"
            ],
            "objetivos": ["Mantener tasa de retenci√≥n >80%", "Incrementar valor promedio en 15%"]
        },
        2: {
            "nombre": "üéØ Clientes Nuevos/Potenciales",
            "descripcion": "Recencia baja, frecuencia en crecimiento, valor variable", 
            "caracteristicas": ["Clientes recientes", "En proceso de fidelizaci√≥n", "Potencial de crecimiento"],
            "estrategias": [
                "üí° Programas de onboarding y bienvenida",
                "üí° Tutoriales y gu√≠as de uso de productos",
                "üí° Ofertas de seguimiento para segunda compra", 
                "üí° Contenido educativo sobre beneficios de la marca"
            ],
            "objetivos": ["Convertir 40% en clientes leales", "Duplicar frecuencia en 6 meses"]
        },
        3: {
            "nombre": "üëë Clientes de Alto Valor",
            "descripcion": "Baja recencia, alta frecuencia y valor monetario elevado",
            "caracteristicas": ["Clientes m√°s valiosos", "Frecuentes y recientes", "Alto gasto total"],
            "estrategias": [
                "üí° Atenci√≥n personalizada y dedicada (account manager)",
                "üí° Ofertas exclusivas y productos premium",
                "üí° Eventos especiales e invitaciones privadas", 
                "üí° Programas VIP con beneficios superiores"
            ],
            "objetivos": ["Retenci√≥n del 95%", "Incrementar valor en 25% anual"]
        }
    }
    
    # Selector de segmento para recomendaciones
    segmento_recomendaciones = st.selectbox(
        "Selecciona un segmento para ver recomendaciones:",
        options=list(recomendaciones.keys()),
        format_func=lambda x: f"Segmento {x}: {recomendaciones[x]['nombre']}"
    )
    
    if segmento_recomendaciones in recomendaciones:
        info = recomendaciones[segmento_recomendaciones]
        
        # Header del segmento
        st.markdown(f"## {info['nombre']}")
        st.write(f"**Descripci√≥n:** {info['descripcion']}")
        
        col_info, col_metrics = st.columns([2, 1])
        
        with col_info:
            st.subheader("üéØ Caracter√≠sticas Principales")
            for caracteristica in info['caracteristicas']:
                st.write(f"‚Ä¢ {caracteristica}")
            
            st.subheader("üöÄ Estrategias Recomendadas")
            for estrategia in info['estrategias']:
                st.write(estrategia)
        
        with col_metrics:
            st.subheader("üìä M√©tricas Objetivo")
            for objetivo in info['objetivos']:
                st.write(f"‚Ä¢ {objetivo}")
            
            # Estad√≠sticas r√°pidas del segmento
            if 'Cluster' in rfm_data.columns:
                segmento_stats = rfm_data[rfm_data['Cluster'] == segmento_recomendaciones]
                st.metric("Clientes en segmento", len(segmento_stats))
                st.metric("Valor promedio", f"${segmento_stats['Monetary'].mean():.2f}")
                st.metric("Recencia promedio", f"{segmento_stats['Recency'].mean():.1f} d√≠as")
    
    # Resumen ejecutivo
    st.markdown("---")
    st.subheader("üìã Resumen Ejecutivo de Segmentaci√≥n")
    
    if 'Cluster' in rfm_data.columns:
        resumen_final = rfm_data.groupby('Cluster').agg({
            'Recency': 'mean',
            'Frequency': 'mean',
            'Monetary': ['mean', 'sum'],
            'Cluster': 'count'
        }).round(2)
        
        resumen_final.columns = ['Recencia Prom', 'Frecuencia Prom', 'Valor Prom', 'Valor Total', 'Clientes']
        st.dataframe(resumen_final)

# Footer
st.markdown("---")
st.markdown("**Proyecto de Miner√≠a de Datos - Grupo 4** | *Clasificaci√≥n de clientes seg√∫n patrones de compra*")
st.markdown("Desarrollado con Streamlit üöÄ")

# Informaci√≥n de debug (opcional - puedes comentar estas l√≠neas)
with st.sidebar:
    st.markdown("---")
    st.markdown("### ‚ÑπÔ∏è Informaci√≥n del Sistema")
    st.write(f"Clientes cargados: {len(rfm_data)}")
    st.write(f"Transacciones: {len(df_original)}")
    if 'Cluster' in rfm_data.columns:
        st.write(f"Segmentos: {rfm_data['Cluster'].nunique()}")